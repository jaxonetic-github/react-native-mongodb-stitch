{"version":3,"sources":["index.ts"],"names":["_isConnectedListeners","Map","fetch","NativeInterface","getCurrentState","addEventListener","listenerOrType","deprecatedHandler","undefined","DeprecatedUtils","warnOnce","DeprecatedTypes","CHANGE_EVENT_NAME","DeprecatedSubscriptions","add","remove","listener","Subscriptions","useNetInfo","type","Types","NetInfoStateType","unknown","isConnected","details","netInfo","setNetInfo","removeEventListener","handler","getConnectionInfo","then","convertState","isConnectionExpensive","eventName","state","set","_eventName","get","delete"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {useState, useEffect} from 'react';\nimport DeprecatedUtils from './internal/deprecatedUtils';\nimport DeprecatedSubscriptions from './internal/deprecatedSubscriptions';\nimport * as DeprecatedTypes from './internal/deprecatedTypes';\nimport Subscriptions from './internal/subscriptions';\nimport * as Types from './internal/types';\nimport NativeInterface from './internal/nativeInterface';\n\nconst _isConnectedListeners = new Map<\n  DeprecatedTypes.IsConnectedHandler,\n  /// @ts-ignore Typescript des not like the trailing comma that Prettier insists upon\n  Types.NetInfoChangeHandler\n>();\n\n/**\n * Returns a `Promise` that resolves to a `NetInfoState` object.\n *\n * @returns A Promise which contains the current connection state.\n */\nexport function fetch(): Promise<Types.NetInfoState> {\n  return NativeInterface.getCurrentState();\n}\n\n/**\n * Subscribe to connection information. The callback is called with a parameter of type\n * [`NetInfoState`](README.md#netinfostate) whenever the connection state changes. Your listener\n * will be called with the latest information soon after you subscribe and then with any\n * subsequent changes afterwards. You should not assume that the listener is called in the same\n * way across devices or platforms.\n *\n * @param listener The listener which is called when the network state changes.\n *\n * @returns An ofunction which can be called to unsubscribe.\n */\nexport function addEventListener(\n  listener: Types.NetInfoChangeHandler,\n): Types.NetInfoSubscription;\n\n/**\n * Deprecated network state listener. You should remove the event name and change your handler to\n * use the new state shape.\n *\n * @deprecated\n *\n * @param type The event type.\n * @param deprecatedHandler The listener.\n *\n * @returns An object with a remove function which can be called to unsubscribe.\n */\nexport function addEventListener(\n  type: string,\n  deprecatedHandler: DeprecatedTypes.ChangeHandler,\n): DeprecatedTypes.Subscription;\n\n// Implementation of the overloaded methods above\nexport function addEventListener(\n  listenerOrType: Types.NetInfoChangeHandler | string,\n  deprecatedHandler: DeprecatedTypes.ChangeHandler | undefined = undefined,\n): Types.NetInfoSubscription | DeprecatedTypes.Subscription {\n  if (typeof listenerOrType === 'string') {\n    DeprecatedUtils.warnOnce();\n\n    if (\n      listenerOrType === DeprecatedTypes.CHANGE_EVENT_NAME &&\n      deprecatedHandler\n    ) {\n      DeprecatedSubscriptions.add(deprecatedHandler);\n      return {\n        remove: (): void => {\n          DeprecatedSubscriptions.remove(deprecatedHandler);\n        },\n      };\n    } else {\n      return {\n        remove: (): void => {},\n      };\n    }\n  } else {\n    const listener = listenerOrType;\n    Subscriptions.add(listener);\n    return (): void => {\n      Subscriptions.remove(listener);\n    };\n  }\n}\n\n/**\n * A React Hook which updates when the connection state changes.\n *\n * @returns The connection state.\n */\nexport function useNetInfo(): Types.NetInfoState {\n  const [netInfo, setNetInfo] = useState<Types.NetInfoState>({\n    type: Types.NetInfoStateType.unknown,\n    isConnected: false,\n    details: null,\n  });\n\n  useEffect((): (() => void) => {\n    return addEventListener(setNetInfo);\n  }, []);\n\n  return netInfo;\n}\n\n/**\n * Deprecated method to remove the listener. You should upgrade to the new API.\n *\n * @deprecated\n *\n * @param type The event type.\n * @param handler The event listener.\n */\nexport function removeEventListener(\n  type: string,\n  handler: DeprecatedTypes.ChangeHandler,\n): void {\n  DeprecatedUtils.warnOnce();\n\n  if (type === DeprecatedTypes.CHANGE_EVENT_NAME) {\n    DeprecatedSubscriptions.remove(handler);\n  }\n}\n\n/**\n * Deprecated method to get the current state. You should upgrade to the new `fetch` method and\n * handle the new state type.\n *\n * @deprecated\n */\nexport function getConnectionInfo(): Promise<DeprecatedTypes.NetInfoData> {\n  DeprecatedUtils.warnOnce();\n  return NativeInterface.getCurrentState().then(DeprecatedUtils.convertState);\n}\n\n/**\n * Deprecated method to tell if the current connection is \"expensive\". Only available on Android.\n * You should now call the `fetch` method and look at the `details.isConnectionExpensive` property.\n *\n * @deprecated\n */\nexport function isConnectionExpensive(): Promise<boolean> {\n  DeprecatedUtils.warnOnce();\n  return NativeInterface.getCurrentState().then(\n    DeprecatedUtils.isConnectionExpensive,\n  );\n}\n\nexport const isConnected = {\n  /**\n   * Deprecated method to listen for changes to the connected boolean. You should now use the\n   * normal `addEventListener` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  addEventListener: (\n    eventName: string,\n    handler: DeprecatedTypes.IsConnectedHandler,\n  ): DeprecatedTypes.Subscription => {\n    if (eventName !== DeprecatedTypes.CHANGE_EVENT_NAME) {\n      return {remove: (): void => {}};\n    }\n\n    const listener = (state: Types.NetInfoState): void => {\n      handler(DeprecatedUtils.isConnected(state));\n    };\n\n    _isConnectedListeners.set(handler, listener);\n    Subscriptions.add(listener);\n\n    return {\n      remove: (): void => {\n        Subscriptions.remove(listener);\n      },\n    };\n  },\n\n  /**\n   * Deprecated method to stop listening for changes to the connected boolean. You should now use\n   * the normal `addEventListener` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  removeEventListener: (\n    _eventName: string,\n    handler: DeprecatedTypes.IsConnectedHandler,\n  ): void => {\n    const listener = _isConnectedListeners.get(handler);\n    listener && Subscriptions.remove(listener);\n    _isConnectedListeners.delete(handler);\n  },\n\n  /**\n   * Deprecated method to get the current is connected boolean. You should now use the normal\n   * `fetch` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  fetch: (): Promise<boolean> => {\n    return NativeInterface.getCurrentState().then(DeprecatedUtils.isConnected);\n  },\n};\n\nexport * from './internal/types';\nexport * from './internal/deprecatedTypes';\n\nexport default {\n  fetch,\n  addEventListener,\n  useNetInfo,\n  removeEventListener,\n  getConnectionInfo,\n  isConnectionExpensive,\n  isConnected,\n};\n"]}